#!/usr/bin/env python
"""Changes solidity metadata in golang contract wrappers to a constant value

This prevents spurious git diffs.

Usage: fix_metadata.py <filename>

Changes <filename> in-place. <filename> must be a golang file.

Modern solc objects have metadata suffixes which vary depending on
incidental compilation context like absolute paths to source files. See
https://solidity.readthedocs.io/en/v0.6.6/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode

Note that the metadata hash is not necessarily the last part of the contract
binary, as a naive reading of that documentation would imply. It can be
followed by static code sections.
https://gitter.im/ethereum/solidity?at=5f10a247d60398014655861f

"""

from __future__ import print_function
import re
import sys
import os.path as path

usage = "Usage: fix_metadata.py <filename>"

def eprint(*args, **kwargs):
    "print to stderr"
    print(*args, file=sys.stderr, **kwargs)

if len(sys.argv) != 2:
    eprint(usage)
    eprint("must include a single filename")
    sys.exit(1)

filepath = sys.argv[1]

if not path.isfile(filepath):
    eprint(usage)
    eprint("{filepath} is not a valid file".format(filepath=filepath))
    sys.exit(1)

if not filepath.endswith(".go"):
    eprint(usage)
    eprint("{filepath} is not a golang file (must end with .go)".format(
        filepath=filepath))
    sys.exit(1)

class RevisedFileContents:

    """Tracks iterating over a file and revising it, line-by-line"""

    def __init__(self, path):
        self.path = path
        self.revised_file_contents = []
        self.f = open(filepath)

    def lines(self):
        "Returns iterator over target file, based on current file position"
        for line in self.f:
            self.revised_file_contents.append(line)
            yield line

    def linenum(self):
        "Returns which line the iteration has reached"
        return len(self.revised_file_contents)

    def update_current_line(self, revised_line):
        "Updates the most recent line with the given revision"
        self.revised_file_contents[-1] = revised_line

    def save_revised_file(self):
        "Saves the contents back out to disk, at the same path"
        open(self.path, 'w').writelines(self.revised_file_contents)


contents = RevisedFileContents(filepath)

for line in contents.lines():
    if line != "// Code generated - DO NOT EDIT.\n":
        eprint(usage)
        eprint("file not generated by abigen -- missing header")
        sys.exit(1)
    break

abigen_sentinel = "github.com/ethereum/go-ethereum/accounts/abi/bind"

for line in contents.lines():
    if abigen_sentinel in line:
        break
else:
    eprint(usage)
    eprint("file not generated by abigen -- missing import")
    sys.exit(1)

metadata_prefix = 'a264697066735822'
metadata_suffix = '[0-9A-Fa-f]{68}64736f6c6343[0-9A-Fa-f]{6}0033'
metadata_regexp = re.compile(metadata_prefix + metadata_suffix)

# metadata_constant is an arbitrary constant stand-in for the metadata suffix
# which the EVM expects (and in some cases, it seems, requires) to find at the
# end of the binary object representing a contract under deployment. See
# file-level docstring.
metadata_constant = (
    'a264697066735822' 
    '00000000000000000000000000000000000000000000000000000000000000000000'
    '64736f6c6343' '000000' '0033'
)

assert re.match(metadata_prefix+metadata_suffix+'$', metadata_constant)

for line in contents.lines():
    if metadata_regexp.search(line):
        if not re.search('^var \w+ = "0x[0-9A-Fa-f]+"$', line):
            eprint(usage)
            eprint("found unexpected metadata match on line {linenum}".format(
                   linenum=contents.linenum()))
            sys.exit(1)
        match_count = 0
        for portion in line.split(metadata_prefix)[1:]:
            if re.match(metadata_suffix, portion):
                match_count += 1
        if match_count != 1:
            eprint("found more than one metadata candidate on line {linenum}"
                   .format(linenum=contents.linenum()))
            eprint("Don't know which one to target, so halting.")
            sys.exit(1)
        revised_line = re.sub(metadata_regexp, metadata_constant, line)
        contents.update_current_line(revised_line)

contents.save_revised_file()
